---
title: "Untitled"
author: "Gould, Katelyn"
date: "1/11/2021"
output: html_document
---

```{r}
#treatment, rate.type, genotype
#treatment,genotype,rate.type
# run nls.multstart on each curve of the original data ####
fit_many <- group_by(mydata_M50Cd,treatment,genotype,rate.type) %>%
  nest() %>%
  mutate(., fit = purrr::map(data, ~nls_multstart(log.rate ~ schoolfield_high(lnc, E, Eh, Th, temp = K, Tc = 20),
                                   data = .x,
                                   iter = 500,
                                   start_lower = c(lnc = -10, E = 0.1, Eh = 0.2, Th = 285),
                                   start_upper = c(lnc = 10, E = 2, Eh = 5, Th = 330),
                                   supp_errors = 'Y',
                                   na.action = na.omit,
                                   lower = c(lnc = -10, E = 0, Eh = 0, Th = 0))))

# run bootstrap over many curves ####
boot_many <- group_by(mydata_M50Cd, treatment, genotype, rate.type) %>%
  # create 200 bootstrap replicates per curve
  do(., boot = modelr::bootstrap(., n = 200, id = 'boot_num')) %>%
  # unnest to show bootstrap number, .id
  unnest() %>%
  # regroup to include the boot_num
  group_by(., treatment, genotype, rate.type, boot_num) %>%
  # run the model using map()
  mutate(fit = map(strap, ~nls_multstart(log.rate ~ schoolfield_high(lnc, E, Eh, Th, temp = K, Tc = 20),
                        data = data.frame(.),
                        iter = 50,
                        start_lower = c(lnc = -10, E = 0.1, Eh = 0.2, Th = 285),
                        start_upper = c(lnc = 10, E = 2, Eh = 5, Th = 330),
                        lower = c(lnc=-10, E=0, Eh=0, Th=0),
                        supp_errors = 'Y')
  ))
```

```{r}
# new data frame for smooth predictions
new_preds <- mydata_M50Cd %>%
  do(., data.frame(K = seq(min(.$K), max(.$K), length.out = 150), stringsAsFactors = FALSE))

# get max and min for each curve
max_min <- group_by(mydata_M50Cd, treatment, genotype, rate.type) %>%
  summarise(., min_K = min(K), max_K = max(K)) %>%
  ungroup()

# create smoother predictions for unbootstrapped models
preds_many <- fit_many %>%
  unnest_legacy(fit %>% map(augment, newdata = new_preds))

# create smoother predictions for bootstrapped replicates
preds_many <- boot_many %>%
   unnest_legacy(fit %>% map(augment, newdata = new_preds)) %>%
  ungroup() %>%
  # group by each value of K and get quantiles
  group_by(., treatment, genotype, rate.type, K) %>%
  summarise(lwr_CI = quantile(.fitted, 0.025),
            upr_CI = quantile(.fitted, 0.975)) %>%
  ungroup() %>%
  merge(., preds_many, by = c("K", "treatment", "genotype", "rate.type")) %>%
  # merge with max_min to delete predictions outside of the max and min temperatures of each curve
  merge(., max_min, by = c("treatment", "genotype", "rate.type")) %>%
  group_by(., treatment, genotype, rate.type) %>%
  filter(., K >= unique(min_K) & K <= unique(max_K)) %>%
  rename(., log.rate = .fitted) %>%
  ungroup()
```


```{r}
# plot predictions 
ggplot(mydata_M50Cd, aes(K - 273.15, ln.rate, group = genotype)) +
  geom_point(alpha = 0.5, size = 0.5) +
  geom_line(data = preds_many) +
  geom_ribbon(aes(ymin = lwr_CI, ymax = upr_CI, fill = genotype), data = preds_many, alpha = .2) + 
  scale_fill_manual(values = c('green4', 'black')) +
  theme_bw(base_size = 12, base_family = 'Helvetica') +
  ylab('log Metabolic rate') +
  xlab('Assay temperature (ºC)') +
  facet_wrap(~ rate.type + treatment, labeller = labeller(.multi_line = FALSE)) +
  theme_bw(base_size = 12, base_family = 'Helvetica') +
  theme(legend.position = c(0.9, 0.15)) +
  ggtitle('Multiple TPCs with confidence intervals')

```

```{r setup, message=FALSE}
remotes::install_github("padpadpadpad/rTPC")
# load packages
library(rTPC)
library(nls.multstart)
library(broom)
library(tidyverse)
```

In the final part of the general pipeline, we demonstrate how multiple models can be fitted to multiple TPCs. Instead of picking all 24 model formulations to demonstrate this approach, we will use only 2 models in this example: **gaussian_1987()** and **sharpeschoolhigh_1981()**.

We can demonstrate the fitting of multiple curves by modelling all 60 TPCs from the example dataset of **rTPC** curve from the example dataset **rTPC**. These TPCs are of respiration and photosynthesis of the aquatic algae, *Chlorella vulgaris*. These algae differed in their growth temperature, `growth_temp`, and how long they had been grown at that temperature, `rate.type`, either for ~100 or ~10 generations.

Using a similar approach to `vignette('fit_many_models')`, models can be fitted to each curve using list columns and **purrr::map()** to fit and store multiple models in a data frame.

When fitting lots of models at once, it is useful to know the progress the code as it may take a long time to run. We can create a progress bar using the [**progress**](https://github.com/r-lib/progress/blob/master/README.md) package. In order to do this, I create a new function **nls_multstart_progress()** that contains a **pb\$tick()** call. This means every time the function is called, it will add one tick onto the progress bar. The progress bar is created using **progress_bar\$new()**, where we set the total length of the progress bar is set by the number of models in total being fit.

```{r fit_multiple_models, warning=FALSE}
# load in data
data("chlorella_tpc")
d <- chlorella_tpc
# when scaling up our code to fit hundreds of models, its nice to have a progress bar
# edit nls_multstart to allow for a progress bar
nls_multstart_progress <- function(formula, data = parent.frame(), iter, start_lower, 
                                   start_upper, supp_errors = c("Y", "N"), convergence_count = 100, 
                                   control, modelweights, ...){
  if(!is.null(pb)){
    pb$tick()
  }
  nls_multstart(formula = formula, data = data, iter = iter, start_lower = start_lower, 
                start_upper = start_upper, supp_errors = supp_errors, convergence_count = convergence_count, 
                control = control, modelweights = modelweights, ...)
}
# start progress bar and estimate time it will take
number_of_models <- 2
number_of_curves <- length(unique(d$curve_id))
# setup progress bar
pb <- progress::progress_bar$new(total = number_of_curves*number_of_models,
                                 clear = FALSE,
                                 format ="[:bar] :percent :elapsedfull")
# fit two chosen model formulation in rTPC
d_fits <- nest(d, data = c(temp, rate)) %>%
  mutate(gaussian = map(data, ~nls_multstart_progress(rate~gaussian_1987(temp = temp, rmax,topt,a),
                        data = .x,
                        iter = c(3,3,3),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'gaussian_1987') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'gaussian_1987') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'gaussian_1987'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'gaussian_1987'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)),
         sharpeschoolhigh = map(data, ~nls_multstart_progress(rate~sharpeschoolhigh_1981(temp = temp, r_tref,e,eh,th, tref = 15),
                        data = .x,
                        iter = c(3,3,3,3),
                        start_lower = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') - 10,
                        start_upper = get_start_vals(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981') + 10,
                        lower = get_lower_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        upper = get_upper_lims(.x$temp, .x$rate, model_name = 'sharpeschoolhigh_1981'),
                        supp_errors = 'Y',
                        convergence_count = FALSE)))
```
```
[=========================================================] 100% 00:00:40
```


Like previous vignettes, the predictions of each model can be estimated using **broom::augment()**. To do this, we first create a new list column containing high resolution temperature values by taking the `min` and `max` of each curve. Next we stack the models and finally we get the new predictions using the **map2()**, which allows us to use both `fit` and `new_data` list columns. After unnesting the `preds` column, we are then left with high resolution predictions for each curve. As this code covers a lot of steps, each line of the code is commented.

```{r preds}
# create new list column of for high resolution data
d_preds <- mutate(d_fits, new_data = map(data, ~tibble(temp = seq(min(.x$temp), max(.x$temp), length.out = 100)))) %>%
  # get rid of original data column
  select(., -data) %>%
  # stack models into a single column, with an id column for model_name
  pivot_longer(., names_to = 'model_name', values_to = 'fit', c(gaussian,sharpeschoolhigh)) %>%
  # create new list column containing the predictions
  # this uses both fit and new_data list columns
  mutate(preds = map2(fit, new_data, ~augment(.x, newdata = .y))) %>%
  # select only the columns we want to keep
  select(curve_id, treatment, genotype, rate.type, model_name, preds) %>%
  # unlist the preds list column
  unnest(preds)
glimpse(d_preds)
```

We can then plot the predictions of each curve using **ggplot2**.

```{r plot, fig.height = 12, fig.width=8}
# plot
ggplot(d_preds) +
  geom_line(aes(temp, .fitted, col = model_name)) +
  geom_point(aes(temp, rate), d) +
  facet_wrap(~curve_id, scales = 'free_y', ncol = 6) +
  theme_bw() +
  theme(legend.position = 'none') +
  scale_color_brewer(type = 'qual', palette = 2) +
  labs(x = 'Temperature (ºC)',
       y = 'Metabolic rate',
       title = 'All fitted thermal performance curves',
       subtitle = 'gaussian in green; sharpeschoolhigh in orange')
```

The traits of each thermal performance curve can also easily be calculated.

```{r params}
# stack models and calculate extra params
d_params <- pivot_longer(d_fits, names_to = 'model_name', values_to = 'fit', c(gaussian,sharpeschoolhigh)) %>%
  mutate(params = map(fit, calc_params)) %>%
  select(curve_id, treatment, genotype, rate.type, model_name, params) %>%
  unnest(params)
glimpse(d_params)
```
```

